package edu.kit.riscjblockits.model.instructionset;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import javafx.util.Pair;


import java.io.BufferedReader;
import java.io.DataInput;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class InstructionSetBuilder {
    public static InstructionSetModel buildInstructionSetModel(InputStream is) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode root;
        try {
            root = objectMapper.readTree(is);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }


        String name = root.path("name").textValue();
        int instructionLength = root.path("instruction_length").asInt();

        JsonNode registers = root.path("registers");
        String programCounterRegister = registers.path("program_counter").toString();
        String[] aluRegisters;


        aluRegisters = objectMapper.readValue(registers.path("alu").toString(), String[].class);

        Map<String, Integer> floatRegisters = objectMapper.readValue(registers.path("float").toString(),
            new TypeReference<HashMap<String, Integer>>(){});
        Map<String, Integer> integerRegisters = objectMapper.readValue(registers.path("integer").toString(),
            new TypeReference<HashMap<String, Integer>>(){});
        JsonNode memory = root.path("memory");
        int memoryWordLength = memory.path("word_length").asInt();
        int memoryAddressLength = memory.path("address_length").asInt();
        String memoryByteOrder = memory.path("byte_order").textValue();

        String[] aluOperations = objectMapper.readValue(root.path("alu_operations").toString(), String[].class);


        Map<String, Pair<String[], String[]>> commandArgumentsTranslationMap = new HashMap<>();
        JsonNode instructionsNode = root.path("instructions");

        // generated by Bing chat
        Iterator<Map.Entry<String, JsonNode>> fields = instructionsNode.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            String instructionName = field.getKey();
            JsonNode instructionValue = field.getValue();

            String opcode = instructionValue.get("opcode").asText();


            String[] arguments = objectMapper.readValue(instructionValue.get("arguments").toString(), String[].class);
            String[] translation = objectMapper.readValue(instructionValue.get("translation").toString(), String[].class);

            commandArgumentsTranslationMap.put(instructionName, new Pair<>(arguments, translation));
        }

        // end of generation


        Map<String, List<Pair<MicroInstruction[], String[]>>> opcodeExecutionTranslationMap = new HashMap<>();

        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            String instructionName = field.getKey();
            JsonNode instructionValue = field.getValue();

            String opcode = instructionValue.get("opcode").asText();


            String[] arguments = objectMapper.readValue(instructionValue.get("arguments").toString(), String[].class);
            String[] execution = objectMapper.readValue(instructionValue.get("execution").toString(), String[].class);
            String[] translation = objectMapper.readValue(instructionValue.get("translation").toString(), String[].class);

            if (!opcodeExecutionTranslationMap.containsKey(opcode))
                opcodeExecutionTranslationMap.put(opcode, new ArrayList<>());


            MicroInstruction[] instructions = new MicroInstruction[execution.length];
            for (int i = 0; i< execution.length; i++) {
                instructions[i] = MicroInstruction.fromJson(execution[i]);
            }
            opcodeExecutionTranslationMap.get(opcode).add(new Pair<>(instructions, translation));
        }

        return new InstructionSetModel(name,
            instructionLength,
            programCounterRegister,
            aluRegisters,
            floatRegisters,
            integerRegisters,
            memoryWordLength,
            memoryAddressLength,
            memoryByteOrder,
            aluOperations,
            commandArgumentsTranslationMap,
            opcodeExecutionTranslationMap);
    }
    private static String readFromInputStream(InputStream inputStream)
        throws IOException {
        StringBuilder resultStringBuilder = new StringBuilder();
        try (BufferedReader br
                 = new BufferedReader(new InputStreamReader(inputStream))) {
            String line;
            while ((line = br.readLine()) != null) {
                resultStringBuilder.append(line).append("\n");
            }
        }
        return resultStringBuilder.toString();
    }
}
